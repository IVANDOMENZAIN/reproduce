---
title: "iBAQ study"
author: "Benjamin Sanchez"
output:
  html_document:
    toc: true
    toc_depth: 2
    theme: united
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Summary

Here we will go through the typical way of deducing protein abundances [fmol/sample] from SILAC/iBAQ data, and compare it to rescaling values to a fix total protein abundance based on MS intensities, to asses the usefulness of the external standard curve and iBAQ data. The main observation that comes from this is that as MS measurements are so variable, it's impossible to find a unique ES curve, hence normalizing to a fix total protein abundance is as good as using the "optimal" fit from the ES curve. We can then use the MS intensity directly and skip both the ES curve and the iBAQ values.
<br>

## Loading and pre-processing data

### Loading packages

```{r warning = FALSE, message = FALSE, results = FALSE}
library(plyr)
library(knitr)
library(biomaRt)
```

```{r echo=FALSE}
read_chunk('loadData.R')
read_chunk('processData.R')
read_chunk('plotData.R')
```

### Loading UPS2

The commercial kit brings 10.6 ug of protein, however only 1.1 ug are injected in the MS:

```{r loadUPS2}
```

### Loading iBAQ data

In the iBAQ data (IS+ES) there are 6 samples: 3 technical replicates (`batch1`, `batch2` & `batch3`) and each of them processed with 2 different MS methods `top5` & `top10`. We will have then 6 different ES curves:

* top5_batch1
* top5_batch2
* top5_batch3
* top10_batch1
* top10_batch2
* top10_batch3

```{r loadIBAQdata}
```

### Getting the ES data

In each sample of the iBAQ data there are:

* 6 ug of IS: yeast samples, all marked; i.e. will appear in the heavy fraction (H)
* 1.1 ug of ES: universal protein standard (UPS2) unmarked; i.e. will appear in the light fraction (L)

```{r splitIBAQdata}
```

### Loading SILAC data

There are 18 different samples:

* 3 biological replicates (`R1`, `R2` & `R3`)
* each with 3 technical replicates (`batch1`, `batch2` & `batch3`)
* each estimated with a different MS method (`top5` & `top10`)

Each injected sample consisted of:

* 6 ug of IS (detected in the H fraction)
* 6 ug of actual sample (detected in the L fraction)

```{r loadSILACdata}
```

### Loading ribosomal proteins

We use a list of ribosomal genes based on Jenner et al. (2012):  http://dx.doi.org/10.1016/j.sbi.2012.07.013


```{r loadRibProteins}
```


## Method 1: iBAQ

Let's start by using the computed iBAQ abundances values by MaxQuant that come in the iBAQ data, which are infered using an ES curve of the UPS2 proteins (in the L fraction). As the data already comes in fmol/sample, the only thing missing is to use the values from the IS (H fraction) together with the normalized L/H ratios in the SILAC data for getting absolute abundances in each sample of the SILAC data (fmol/sample), by doing:

`abundance(sample) = (L/H)ratio * abundance(IS)`

```{r getSampleAbundance}
```

```{r}
SILACdata <- getSampleAbundance(SILACdata,ISdata,'iBAQ')
```

## Method 2: Rescaling iBAQ values

As iBAQ values don't add up always to the same totals (see later figure 5), we should asses the benefits of rescaling all of these values to add up to the injected amounts:

`abundance = (iBAQ abundance)*(injected amount)/(sum of all iBAQ abundances*MW values)`

```{r rescaleData}
```

```{r}
ESdata    <- rescaleData(ESdata,'Abundance.iBAQ.ES.','iBAQrescaled.ES.',1.1e6) #1.1 ug = 1.1*10^6 pg
ISdata    <- rescaleData(ISdata,'Abundance.iBAQ.IS.','iBAQrescaled.IS.',6e6)   #6 ug = 6*10^6 pg
```

We now use the absolute abundances from the IS (fmol/sample) to infer absolute abundances in each sample of the SILAC data (fmol/sample):

```{r}
SILACdata <- getSampleAbundance(SILACdata,ISdata,'iBAQrescaled')
```

## Method 3: Rescaling abundances to total MS intensity

The alternative: To skip iBAQ values and ES curves entirely, and to assume all normalized MS intensities added up together (mass-wise) should be proportional to the injected amount in ug (TPA approach):

`abundance = (MS intensity)*(injected amount)/(sum of all MS intensities*MW values)`

We then need to first normalize all MS intensitiy values from the iBAQ data by the number of theoretical peptides for each protein. We will use sequence length as proxy for number of theoretical peptides:

```{r normalizeIntensities}
```

```{r}
ESdata <- normalizeIntensities(ESdata)
ISdata <- normalizeIntensities(ISdata)
```

Now we rescale the data:

```{r}
ESdata    <- rescaleData(ESdata,'Intensity.L.T4h_','MSrescaled.ES.',1.1e6) #1.1 ug = 1.1*10^6 pg
ISdata    <- rescaleData(ISdata,'Intensity.H.T4h_','MSrescaled.IS.',6e6)   #6 ug = 6*10^6 pg
SILACdata <- getSampleAbundance(SILACdata,ISdata,'MSrescaled')
```

Note that we have essentially created a linear model:

`abundance = m*MSintensity`, where `m = (6 ug)/(sum of all MSintensities*MWs)`

`log(abundance) = log(MSintensity) + log(m)` -> linear model with a = 1 and b = log(m) in the log space.

## Additional method: MS intensities using an ES curve

As we do not have the normalized intensities for the MaxQuant calculations of iBAQ abundances, we will use an additional method only for comparing the ES curves quality. Abundance of the IS here is computed by building a log-log standard curve for the ES and applying it to the normalized MS intensities from the IS (H fraction). Note that said ES curve MUST have slope = 1, as the underlying assumption is that MS intensities are linearly proportional to the mass of the corresponding proteins, therefore:

`moles = m*MSint`

`log10(moles) = log10(m*MSint)`

`log10(moles) = log10(MSint) + log10(m)`

So if the fit is done in the log space, we fix the ES curve to always have slope = 1, and find the corresponding fit for the intercept:

```{r interpolateAbundance}
```

```{r}
ISdata    <- interpolateAbundance(ISdata,'Intensity.H.T4h_','Interp.IS.')
ESdata    <- interpolateAbundance(ESdata,'Intensity.L.T4h_','Interp.ES.')
SILACdata <- getSampleAbundance(SILACdata,ISdata,'Interp')
```

## Method comparison

### Data prediction

Let's start by comparing the ES values predicted by each method to the actual UPS2 values. For that we need a couple of plotting functions:

```{r plotScatter}
```

```{r plotESdata}
```

We now plot the comparison for all 3 methods:

```{r fig.height = 3, fig.width = 10, fig.align="center"}
par(mfcol = c(1,3), mar = c(4,4,2,1), cex = 1)
FCups2IBAQ <- plotESdata(ESdata,'iBAQ')
FCups2IR   <- plotESdata(ESdata,'iBAQrescaled')
FCups2MSR  <- plotESdata(ESdata,'MSrescaled')
```

<center>**Figure 1: Comparison of predicted Vs real abundance values [fmol/sample] from UPS2, according to all 3 methods. Green is a FC < 2, yellow between 2 and 10, and red > 10.**</center>
<br>

We see that all predictions are very similar; by using ES curves (methods 1-2) we don't gain much prediction power than if we just rescale the data (method 3).

We can also see this if we plot the data between methods: For that we define a function that gives all possible combinations between replicates. For instance, for biological replicates, the text in the variable's label regarding biological replicate (`.R1.1`, `.R2.1` and `.R3.1`) will be first removed, and then 2 columns will be paired up if the rest of the name matches (meaning it's the same technical replicate/MS method but 2 different biological replicates). We can also use it to compare between methods by removing the method's name:

```{r getReplicateData}
```

```{r plotVariability}
```

```{r fig.height = 4, fig.width = 10, fig.align="center"}
abundanceIBAQ <- SILACdata[,c(1,grep('Abundance.iBAQ.R',names(SILACdata)))]
abundanceIR   <- SILACdata[,c(1,grep('Abundance.iBAQrescaled.R',names(SILACdata)))]
abundanceMSR  <- SILACdata[,c(1,grep('Abundance.MSrescaled.R',names(SILACdata)))]
IRvsIBAQ  <- cbind(abundanceIBAQ[,-1],abundanceIR[,-1])
MSRvsIBAQ <- cbind(abundanceIBAQ[,-1],abundanceMSR[,-1])
par(mfrow = c(1,2), mar = c(4,4,2,1), cex = 1)
plotVariability(IRvsIBAQ, c('iBAQ.R','iBAQrescaled.R'), '', 'iBAQ [fmol/sample]', 'iBAQ rescaled [fmol/sample]', FALSE)
plotVariability(MSRvsIBAQ, c('iBAQ.R','MSrescaled.R'), '', 'iBAQ [fmol/sample]', 'MS rescaled [fmol/sample]', FALSE)
```

<center>**Figure 2: Comparison of predictions [fmol/sample] between all 3 methods. Green is a FC < 2, yellow between 2 and 10, and red > 10.**</center>
<br>

Finally, let's see how are the predictions of ribosomal subunits stoichiometry. For that first we create dataframes with only ribosomal proteins:

```{r getRPdata}
```

```{r}
rpIBAQ <- getRPdata(abundanceIBAQ,RP)
rpIR   <- getRPdata(abundanceIR,RP)
rpMSR  <- getRPdata(abundanceMSR,RP)
```

Now we can plot for each method the corresponding data

```{r plotRPdata}
```


```{r fig.height = 10, fig.width = 8, fig.align="center"}
par(mfrow = c(3,1), mar = c(4,4,2,1), cex = 1)
FCrpIBAQ <- plotRPdata(rpIBAQ,'iBAQ')
FCrpIR   <- plotRPdata(rpIR,'iBAQrescaled')
FCrpMSR  <- plotRPdata(rpMSR,'MSrescaled')
```

<center>**Figure 3: Comparison of predicted ribosomal subunit abundances [fmol/sample], according to all 3 methods. Colors correspond to different technical replicates. The median value is displayed with a segmented line, and the median fold change to that line for all data is displayed.**</center>
<br>

These distributions are not very different between them, as we can see in the cumulative distributions:

```{r plotCumulativeDistrib}
```

```{r warning = FALSE, fig.height = 5, fig.width = 8, fig.align="center"}
ups2FC <- data.frame(FCups2IBAQ,FCups2IR,FCups2MSR)
rpFC   <- data.frame(FCrpIBAQ,FCrpIR,FCrpMSR)
par(mfrow = c(1,2), mar = c(4,4,2,1), cex = 1)
plotCumulativeDistrib(ups2FC,'UPS2 abundance error')
plotCumulativeDistrib(rpFC,'Ribosomal stoichiometry variability')
```

<center>**Figure 4: Cumulative distributions of absolute fold changes for both accuracy evaluation metrics:  differences of predicted Vs experimental values of UPS2 (left) and differences to median value in ribosomal measurements (right). Colors represent the 3 methods: iBAQ (red), iBAQ rescaled (green) and MS rescaled (blue). **</center>
<br>

### Protein totals

Let's now take a look at the total detected protein amount in each of the 6 samples of IS, for all 3 methods:

```{r plotTotalProt}
```

```{r fig.height = 3, fig.width = 10, fig.align="center"}
par(mfcol = c(1,3), mar = c(1,2.5,2,1), cex = 1)
plotTotalProt(ISdata,'Abundance.iBAQ.IS')
plotTotalProt(ISdata,'Abundance.iBAQrescaled.IS')
plotTotalProt(ISdata,'Abundance.MSrescaled.IS')
```

<center>**Figure 5: Total detected protein amounts in all 6 IS, according to all 3 methods.**</center>
<br>

Let's also take a look at the total detected protein amount of each of the 18 samples, colored by the original ES curve used for the calibration (figure 5):

```{r fig.height = 3, fig.width = 10, fig.align="center"}
par(mfcol = c(1,3), mar = c(1,2.5,2,1), cex = 1)
plotTotalProt(SILACdata,'Abundance.iBAQ.R..1_')
plotTotalProt(SILACdata,'Abundance.iBAQrescaled.R..1_')
plotTotalProt(SILACdata,'Abundance.MSrescaled.R..1_')
```

<center>**Figure 6: Total detected protein amounts in all 18 samples, according to all 3 methods.**</center>
<br>

The total detected protein seems to vary quite a bit among samples calculated with the conventional method, and as expected this reduces if we rescale the IS abundances.

### ES curves

Let's now take a look at the ES data + standard curves from method 3, compared to the alternative method (using an ES curve on the normalized MS intensities). For that we need:

* A function for plotting a linear fit (with a slope = 1):

```{r plotLM}
```

* A function for plotting the external standard:

```{r plotES}
```

* A function for plotting all 6 external standards (together or separate):

```{r plotAllES}
```

Note that we cannot look at the ES curves of methods 1 and 2 as we do not have the values for the normalized MS intensities by MaxQuant (the software does not provide them).

```{r fig.align="center"}
ISpos <- grep('Intensity.H.T4h',names(ISdata))   #All 6 MS intensity values from the IS (H fraction)
Hdata   <- ISdata[,ISpos]*ISdata$Mol..weight..kDa.
scaling <- 6e6/colSums(Hdata, na.rm = TRUE)
plotAllES(ESdata,'Intensity.L.T4h_',scaling,FALSE)
```

<center>**Figure 7: ES curves (log10(abundance [fmol/sample]) in y-axis Vs log10(MS intensity) in x-axis), with (green) and without (red) rescaling. Within each of the 4 orders of magnitude, each symbol corresponds to a different protein.**</center>
<br>

The red fits give us the transformation from light (L) MS intensity of the UPS2 proteins to abundance (fmol/sample) with the traditional approach. But they don't look the best (consider they are in log), many other curves (as the green fits) can almost equally well fit that data. Let's see everything in the same plot:

```{r fig.align="center"}
plotAllES(ESdata,'Intensity.L.T4h_',scaling,TRUE)
```

<br>
<center>**Figure 8: ES curves (log10(abundance [fmol/sample]) in y-axis Vs log10(MS intensity) in x-axis), with (green) and without (red) rescaling. Average coefficient of variation (CVm) within each protein is shown in the upper left corner.**</center>
<br>

Note that the MS precision is quite poor: the same protein detection can vary almost a full order of magnitude in some cases. This supports the idea that an alternative linear fit can replace the original ES curve, as both are an approximation anyway.
<br>

### Assesing variability

We now display the variability of the final abundance data between biological and technical replicates, for methods 1, 3 and 4. Using variability plots and a PCA:

```{r plotPCA}
```

```{r fig.height = 8, fig.width = 10, fig.align="center"}
par(mfrow = c(3,3), mar = c(0, 0, 1, 0) + 0.5, cex = 1)
# Top row: MaxQuant
plotVariability(abundanceIBAQ[,-1],c('.R1.1','.R2.1','.R3.1'),'Biological Variability')
plotVariability(abundanceIBAQ[,-1],c('_batch1','_batch2','_batch3'),'Technical Variability')
plotPCA(abundanceIBAQ[,-1],'PCA')
# Middle row: Interpolating with ES curve
plotVariability(abundanceIR[,-1],c('.R1.1','.R2.1','.R3.1'),'Biological Variability')
plotVariability(abundanceIR[,-1],c('_batch1','_batch2','_batch3'),'Technical Variability')
plotPCA(abundanceIR[,-1],'PCA')
# Bottom row: Rescaling
plotVariability(abundanceMSR[,-1],c('.R1.1','.R2.1','.R3.1'),'Biological Variability')
plotVariability(abundanceMSR[,-1],c('_batch1','_batch2','_batch3'),'Technical Variability')
plotPCA(abundanceMSR[,-1],'PCA')
```

<center>**Figure 9: Comparison of data variability from iBAQ (top row), rescaling iBAQ (middle row) and rescaling the normalized MS intensities (bottom row). In the variability plots (left and middle columns, log10(abundance [fmol/sample]) both in the x-axis and y-axis), 2 abundance values for a given protein are plotted if they belong to the same replicate (biological or technical, respectively), and green is a FC < 2, yellow between 2 and 10, and red > 10. In the PCA plots (right column), colors refer to technical replicates and shapes to biological replicates.**</center>
<br>

We see a lower median fold change in the technical replicates + a better separation of the "technical clusters" in the PCA when we use rescale the normalized MS abundancies (PC1 represents less variability). This means that by using rescaled MS data we achieve lower variability between technical replicates than the other 2 methods.

### Assesing technical variability

Let's look further into the reduction of technical variability:

```{r fig.width = 4, fig.align="center"}
par(mfrow = c(1,1), mar = c(4,4,1.5,0.5))
names      <- c('_batch1','_batch2','_batch3')
FCtechIBAQ <- getReplicateData(abundanceIBAQ[,-1],names,2,FALSE)
FCtechIR   <- getReplicateData(abundanceIR[,-1],names,2,FALSE)
FCtechMSR  <- getReplicateData(abundanceMSR[,-1],names,2,FALSE)
techFC     <- data.frame(FCtechIBAQ[,2],FCtechIR[,2],FCtechMSR[,2])
plotCumulativeDistrib(techFC,'Technical variability')
```

<center>**Figure 10: Fold change cumulative distributions for all 3 methods. A fold change of 2 is indicated with a vertical segmented line.**</center>
<br>

We can also look at technical variability by plotting each FC to the basal abundance, together with a "UPS2 window" that shows the abundance levels that are detected by the UPS2:

```{r plotFCvsAbundance}
```

We can now compare again the 3 methods:

```{r fig.height = 4, fig.width = 10, fig.align="center"}
par(mfrow = c(1,3), mar = c(4,4,1.5,0.5))
sample1 <- plotFCvsAbundance(SILACdata,ESdata,'Abundance.iBAQ.R..1_',FALSE)
sample2 <- plotFCvsAbundance(SILACdata,ESdata,'Abundance.iBAQrescaled.R..1_',FALSE)
sample3 <- plotFCvsAbundance(SILACdata,ESdata,'Abundance.MSrescaled.R..1_',FALSE)
```

<center>**Figure 11: Fold change Vs abundances for all 3 methods. The detection window of UPS2 and the UPS2 datapoints are highlighted in yellow.**</center>
<br>

We see that in all 3 cases more than 80% of the data falls within the detection range of UPS2, which is good. However, all 3 datasets look similar in shape, so instead let's look at the trend of the data with the help of smooth splines:

```{r plotSplines}
```

Plotting now all data together with the smoothing splines for each method:

```{r fig.width = 4, fig.align="center"}
par(mfrow = c(1,1), mar = c(4,4,1.5,0.5))
plotSplines(SILACdata,ESdata)
```

<center>**Figure 12: Fold change Vs abundances for all 3 methods + smoothing splines (colors corresponding to the colors in figure 6). The detection window of UPS2 is highlighted in yellow.**</center>
<br>

We now see that our proposed method of rescaling by MS intensities has less overall variability than the both iBAQ and rescaled iBAQ, both for lowly and highly abundant proteins.

In conclusion, we can skip entirely the UPS2 data and just assume that the MS intensities should always adds up to a given protein amount. With this, we can reproduce very closely the ES curves, and achieve more consistent results across samples. In this approach, the iBAQ run is only used to do the rescaling, but this could be equally performed with any SILAC run.
<br>
