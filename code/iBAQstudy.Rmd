---
title: "iBAQ study"
author: "Benjamin Sanchez"
output:
  html_document:
    toc: true
    toc_depth: 2
    theme: united
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Summary

Here we will go through the typical way of deducing protein abundances [fmol/sample] from SILAC/iBAQ data, and compare it to rescaling values to a fix total protein abundance based on MS intensities, to asses the usefulness of the external standard curve and iBAQ data. The main observation that comes from this is that as MS measurements are so variable, it's impossible to find a unique ES curve, hence normalizing to a fix total protein abundance is as good as using the "optimal" fit from the ES curve. We can then use the MS intensity directly and skip both the ES curve and the iBAQ values.
<br>

## Loading and pre-processing data

### Loading packages

```{r warning = FALSE, message = FALSE, results = FALSE}
library(knitr)
```

```{r echo=FALSE}
read_chunk('loadData.R')
read_chunk('combineData.R')
read_chunk('plotData.R')
```

### Loading UPS2

The commercial kit brings 10.6 ug of protein, however only 1.1 ug are injected in the MS:

```{r loadUPS2}
```

### Loading iBAQ data

In the iBAQ data (IS+ES) there are 6 samples: 3 technical replicates (`batch1`, `batch2` & `batch3`) and each of them processed with 2 different MS methods `top5` & `top10`. We will have then 6 different ES curves:

* top5_batch1
* top5_batch2
* top5_batch3
* top10_batch1
* top10_batch2
* top10_batch3

```{r loadIBAQdata}
```

### Getting the ES data

In each sample of the iBAQ data there are:

* 6 ug of IS: yeast samples, all marked; i.e. will appear in the heavy fraction (H)
* 1.1 ug of ES: universal protein standard (UPS2) unmarked; i.e. will appear in the light fraction (L)

```{r splitIBAQdata}
```

### Loading SILAC data

There are 18 different samples:

* 3 biological replicates (`R1`, `R2` & `R3`)
* each with 3 technical replicates (`batch1`, `batch2` & `batch3`)
* each estimated with a different MS method (`top5` & `top10`)

Each injected sample consisted of:

* 6 ug of IS (detected in the H fraction)
* 6 ug of actual sample (detected in the L fraction)

```{r loadSILACdata}
```

### Normalizing MS values

For all MS intensitiy values in iBAQ, we need to normalize by the number of theoretical peptides for each protein. We will use sequence length as proxy for number of theoretical peptides:

```{r normalizeIntensities}
```

```{r}
ESdata <- normalizeIntensities(ESdata)
ISdata <- normalizeIntensities(ISdata)
```

## Method 1: MaxQuant

Let's start by using the computed abundance values by MaxQuant that come in the file. As they are already in fmol/sample, the only thing missing is to use the values from the IS (H fraction) together with the normalized L/H ratios in the SILAC data for getting absolute abundances in each sample of the SILAC data (fmol/sample), by doing:

`abundance(sample) = (L/H)ratio * abundance(IS)`

```{r getSamplesAbundance}
```

```{r}
SILACdata <- getSampleAbundance(SILACdata,ISdata,'MaxQuant')
```

## Method 2: Using an ES curve

Abundance of the IS can be computed by building a log-log standard curve for the ES and applying it to the MS intensities from the IS (H fraction). Note that said ES curve MUST have slope = 1, as the underlying assumption is that MS intensities are linearly proportional to the mass of the corresponding proteins, therefore:

`moles = m*MSint`

`log10(moles) = log10(m*MSint)`

`log10(moles) = log10(MSint) + log10(m)`

So if the fit is done in the log space, we fix the ES curve to always have slope = 1, and find the corresponding fit for the intercept:

```{r interpolateAbundance}
```

```{r}
ISdata <- interpolateAbundance(ISdata,'Intensity.H.T4h_','Interp.IS.')
ESdata <- interpolateAbundance(ESdata,'Intensity.L.T4h_','Interp.ES.')
```

We now use the absolute abundances from the IS (fmol/sample) to infer absolute abundances in each sample of the SILAC data (fmol/sample):

```{r}
SILACdata <- getSampleAbundance(SILACdata,ISdata,'Interp')
```

## Method 3: Rescaling MaxQuant values

As MaxQuant values don't add up always to the same values (see later figure 1), we should also asses the benefits of rescaling all of those values to add up to the injected amounts:

`abundance = (MaxQuant abundance)*(injected amount)/(sum of all MaxQuant abundances*MW values)`

```{r rescaleData}
```

```{r}
ESdata    <- rescaleData(ESdata,'Abundance.MaxQuant.ES.','MQrescaled.ES.',1.1e6) #1.1 ug = 1.1*10^6 pg
ISdata    <- rescaleData(ISdata,'Abundance.MaxQuant.IS.','MQrescaled.IS.',6e6) #6 ug = 6*10^6 pg
SILACdata <- getSampleAbundance(SILACdata,ISdata,'MQrescaled')
```

## Method 4: Rescaling abundances to total MS intensity

The alternative: To skip MaxQuant values and ES curves entirely, and to assume all normalized MS intensities added up together (mass-wise) should be proportional to the injected amount in ug (TPA approach):

`abundance = (MS intensity)*(injected amount)/(sum of all MS intensities*MW values)`

```{r}
ESdata    <- rescaleData(ESdata,'Intensity.L.T4h_','MSrescaled.ES.',1.1e6) #1.1 ug = 1.1*10^6 pg
ISdata    <- rescaleData(ISdata,'Intensity.H.T4h_','MSrescaled.IS.',6e6) #6 ug = 6*10^6 pg
SILACdata <- getSampleAbundance(SILACdata,ISdata,'MSrescaled')
```

## Method comparison

Let's take a look at the total detected protein amount in each of the 6 samples of IS, for all 3 methods:

```{r plotTotalProt}
```

```{r fig.height = 4, fig.width = 10, fig.align="center"}
par(mfcol = c(1,4), mar = c(1,2.5,2,1), cex = 1)
plotTotalProt(ISdata,'Abundance.MaxQuant.IS')
plotTotalProt(ISdata,'Abundance.Interp.IS')
plotTotalProt(ISdata,'Abundance.MQrescaled.IS')
plotTotalProt(ISdata,'Abundance.MSrescaled.IS')
```

<center>**Figure 1: Total detected protein amounts in all 6 IS, according to all 4 methods.**</center>
<br>

Let's take a look at the total detected protein amount of each of the 18 samples, colored by the original ES curve used for the calibration (figure 1):

```{r fig.height = 4, fig.width = 10, fig.align="center"}
par(mfcol = c(1,4), mar = c(1,2.5,2,1), cex = 1)
plotTotalProt(SILACdata,'Abundance.MaxQuant.R..1_')
plotTotalProt(SILACdata,'Abundance.Interp.R..1_')
plotTotalProt(SILACdata,'Abundance.MQrescaled.R..1_')
plotTotalProt(SILACdata,'Abundance.MSrescaled.R..1_')
```

<center>**Figure 2: Total detected protein amounts in all 18 samples, according to all 4 methods.**</center>
<br>

The total detected protein seems to vary quite a bit among samples depending on the ES for any method with an ES curve, and as expected this reduces if we rescale the IS abundances.

Let's now take a look at the ES data + standard curves. For that we need:

* A function for plotting a linear fit (with a slope = 1):

```{r plotLM}
```

* A function for plotting the external standard:

```{r plotES}
```

* A function for plotting all 6 external standards (together or separate):

```{r plotAllES}
```

Now we can take a look at all 6 ES curves from method 2, and also for method 4, as we have essentially created an alternative linear model:

`abundance = m*MSintensity`, where `m = (6 ug)/(sum of all MSintensities*MWs)`

`log(abundance) = log(MSintensity) + log(m)` -> linear model with a = 1 and b = log(m)

Note that we cannot look at the ES curves of methods 1 and 3 as we do not have the values for the normalized MS intensities by MaxQuant (the software does not provide them).

```{r fig.align="center"}
ISpos <- grep('Intensity.H.T4h',names(ISdata))   #All 6 MS intensity values from the IS (H fraction)
Hdata   <- ISdata[,ISpos]*ISdata$Mol..weight..kDa.
scaling <- 6e6/colSums(Hdata, na.rm = TRUE)
plotAllES(ESdata,'Intensity.L.T4h_',scaling,FALSE)
```

<center>**Figure 3: ES curves (log10(abundance [pg/sample]) in y-axis Vs log10(MS intensity) in x-axis), from method 2 (red) Vs method 4 (green)**</center>
<br>

The red fits give us the transformation from light (L) MS intensity of the UPS2 proteins to abundance (fmol/sample) with the traditional method. But they don't look the best (consider they are in log), many other curves (as the green fits) can almost equally well fit that data. Let's see everything in the same plot:

```{r fig.align="center"}
plotAllES(ESdata,'Intensity.L.T4h_',scaling,TRUE)
```

<br>
<center>**Figure 4: ES curves (abundance Vs MS intensities of UPS2), from method 2 (red) Vs method 4 (green). Average coefficient of variation (CVm) within each protein is shown in the upper left corner.**</center>
<br>

Note that the MS precision is quite poor: the same protein detection can vary almost a full order of magnitude in some cases. This supports the idea that an alternative linear fit can replace the original ES curve, as both are an approximation anyway.
<br>

We now display the variability of the final abundance data between biological and technical replicates, for methods 1, 3 and 4. First we define a scatter plot helping function:

```{r plotScatter}
```

We now define a function that plots all possible combinations between replicates. For instance, for biological replicates, the text in the variable's label regarding biological replicate (`.R1.1`, `.R2.1` and `.R3.1`) will be first removed, and then 2 columns will be plotted against each other if the rest of the name matches (meaning it's the same technical replicate/MS method but 2 different biological replicates).

```{r plotVariability}
```

Finally, we define a PCA function to see how the samples cluster:

```{r plotPCA}
```

Let's now see the results of those plots:

```{r fig.height = 8, fig.width = 10, fig.align="center"}
par(mfrow = c(3,3), mar = c(0, 0, 1, 0) + 0.5, cex = 1)
# Top row: MaxQuant
abundance <- SILACdata[,grep('Abundance.MaxQuant.R',names(SILACdata))]
plotVariability(abundance,c('.R1.1','.R2.1','.R3.1'),'Biological Variability')
plotVariability(abundance,c('_batch1','_batch2','_batch3'),'Technical Variability')
plotPCA(abundance,'PCA')
# Middle row: Interpolating with ES curve
abundance <- SILACdata[,grep('Abundance.MQrescaled.R',names(SILACdata))]
plotVariability(abundance,c('.R1.1','.R2.1','.R3.1'),'Biological Variability')
plotVariability(abundance,c('_batch1','_batch2','_batch3'),'Technical Variability')
plotPCA(abundance,'PCA')
# Bottom row: Rescaling
abundance <- SILACdata[,grep('Abundance.MSrescaled.R',names(SILACdata))]
plotVariability(abundance,c('.R1.1','.R2.1','.R3.1'),'Biological Variability')
plotVariability(abundance,c('_batch1','_batch2','_batch3'),'Technical Variability')
plotPCA(abundance,'PCA')
```

<center>**Figure 5: Comparison of data variability from MaxQuant (top row), rescaling MaxQuant (middle row) and rescaling the original MS intensities (bottom row). In the variability plots (left and middle columns, log10(abundance [fmol/sample]) both in the x-axis and y-axis), 2 abundance values for a given protein are plotted if they belong to the same replicate (biological or technical, respectively), and green is a FC < 2, yellow between 2 and 10, and red > 10. In the PCA plots (right column), colors refer to technical replicates and shapes to biological replicates.**</center>
<br>

We see a lower median fold change in the technical replicates + a better separation of the "technical clusters" in the PCA when we use rescale the original MS abundancies (PC1 represents less variability). This means that by using rescaled MS data we achieve lower variability between technical replicates than the other 2 methods.

Let's look further into the reduction of variability by plotting all possible FC (i.e. both between biological and technical replicates). For that we define the following function:

```{r getFCvsAbundance}
```

And the following plotting function that will plot each FC to the basal abundance, together with a "UPS2 window" that shows the abundance levels that are detected by the UPS2:

```{r plotFCvsAbundance}
```

We can now compare again the 3 methods:

```{r fig.height = 4, fig.width = 10, fig.align="center"}
par(mfrow = c(1,3), mar = c(4,4,1.5,0.5))
sample1 <- plotFCvsAbundance(SILACdata,ESdata,'Abundance.MaxQuant.R..1_',FALSE)
sample2 <- plotFCvsAbundance(SILACdata,ESdata,'Abundance.MQrescaled.R..1_',FALSE)
sample3 <- plotFCvsAbundance(SILACdata,ESdata,'Abundance.MSrescaled.R..1_',FALSE)
```

<center>**Figure 6: Fold change Vs abundances for all 3 methods. The detection window of UPS2 and the UPS2 datapoints are highlighted in yellow.**</center>
<br>

We see that in all 3 cases more than 80% of the data falls within the detection range of UPS2, which is good. However, all 3 datasets look similar in shape, so instead let's look at the trend of the data with the help of smooth splines:

```{r plotSplines}
```

Plotting now all data together with the smoothing splines for each method:

```{r fig.width = 4, fig.align="center"}
par(mfrow = c(1,1), mar = c(4,4,1.5,0.5))
plotSplines(SILACdata,ESdata)
```

<center>**Figure 7: Fold change Vs abundances for all 3 methods + smoothing splines (colors corresponding to the colors in figure 6). The detection window of UPS2 is highlighted in yellow.**</center>
<br>

We now see that our proposed method of rescaling by MS intensities has less overall variability than the both MaxQuant and rescaled MaxQuant, both for lowly and highly abundant proteins.

In conclusion, we can skip entirely the UPS2 data and just assume that the MS intensities should always adds up to a given protein amount. With this, we can reproduce very closely the ES curves, and achieve more consistent results across samples. In this approach, the iBAQ run is only used to do the rescaling, but this could be equally performed with any SILAC run.
<br>


## To-do's

* Plot comparing to real UPS2 values
* Is the order in ES data always the same?
* Validation to stoichiometry of ribosomal proteins

