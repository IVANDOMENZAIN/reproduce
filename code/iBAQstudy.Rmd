---
title: "iBAQ study"
author: "Benjamin Sanchez"
output:
  html_document:
    toc: true
    toc_depth: 2
    theme: united
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Summary

Here we will go through the typical way of deducing protein abundances [fmol/sample] from SILAC/iBAQ data, and compare it to rescaling values to a fix total protein abundance based on MS intensities, to asses the usefulness of the external standard curve and iBAQ data. The main observation that comes from this is that as MS measurements are so variable, it's impossible to find a unique ES curve, hence normalizing to a fix total protein abundance is as good as using the "optimal" fit from the ES curve. We can then use the MS intensity directly and skip both the ES curve and the iBAQ values.
<br>

## Loading and pre-processing data

### Loading packages

```{r warning = FALSE, message = FALSE, results = FALSE}
library(knitr)
```

```{r echo=FALSE}
read_chunk('loadData.R')
read_chunk('combineData.R')
read_chunk('plotData.R')
```

### Loading UPS2

The commercial kit brings 10.6 ug of protein, however only 1.1 ug are injected in the MS:

```{r loadUPS2}
```

### Loading iBAQ data

In the iBAQ data (IS+ES) there are 6 samples: 3 technical replicates (`batch1`, `batch2` & `batch3`) and each of them processed with 2 different MS methods `top5` & `top10`. We will have then 6 different ES curves:

* top5_batch1
* top5_batch2
* top5_batch3
* top10_batch1
* top10_batch2
* top10_batch3

```{r loadIBAQdata}
```

### Getting the ES data

In each sample of the iBAQ data there are:

* 6 ug of IS: yeast samples, all marked; i.e. will appear in the heavy fraction (H)
* 1.1 ug of ES: universal protein standard (UPS2) unmarked; i.e. will appear in the light fraction (L)

```{r getESdata}
```

### Loading SILAC data

There are 18 different samples:

* 3 biological replicates (`R1`, `R2` & `R3`)
* each with 3 technical replicates (`batch1`, `batch2` & `batch3`)
* each estimated with a different MS method (`top5` & `top10`)

Each injected sample consisted of:

* 6 ug of IS (detected in the H fraction)
* 6 ug of actual sample (detected in the L fraction)

```{r loadSILACdata}
```

### Normalizing MS values

For all MS intensitiy values in iBAQ, we need to normalize by the number of theoretical peptides for each protein. We will use sequence length as proxy for number of theoretical peptides:

```{r normalizeIntensities}
```

```{r}
ESdata    <- normalizeIntensities(ESdata)
iBAQdata  <- normalizeIntensities(iBAQdata)
```

## Method 1: MaxQuant

Let's start by using the computed abundance values by MaxQuant that come in the file. As they are already in fmol/sample, the only thing missing is to use the values from the IS (H fraction) together with the normalized L/H ratios in the SILAC data for getting absolute abundances in each sample of the SILAC data (fmol/sample), by doing:

`abundance(sample) = (L/H)ratio * abundance(IS)`

```{r getSamplesAbundance}
```

```{r}
SILACdata <- getSampleAbundance(SILACdata,iBAQdata,'Abundance.MaxQuant')
```

## Method 2: Using an ES curve

Abundance of the IS can be computed by building a log-log standard curve for the ES and applying it to the MS intensities from the IS (H fraction). Note that said ES curve MUST have slope = 1, as the underlying assumption is that iBAQ values are linearly proportional to the mass of the corresponding proteins, therefore:

`moles = m*iBAQ`

`log10(moles) = log10(m*iBAQ)`

`log10(moles) = log10(iBAQ) + log10(m)`

So if the fit is done in the log space, we fix the ES curve to always have slope = 1, and find the corresponding fit for the intercept:

```{r interpolateAbundance}
```

```{r}
iBAQdata <- interpolateAbundance(iBAQdata,'Intensity.H.T4h_','Abundance.Interp.IS.')
ESdata   <- interpolateAbundance(ESdata,'Intensity.L.T4h_','Abundance.Interp.ES.')
```

We now use the absolute abundances from the IS (fmol/sample) to infer absolute abundances in each sample of the SILAC data (fmol/sample):

```{r}
SILACdata <- getSampleAbundance(SILACdata,iBAQdata,'Abundance.Interp')
```

## Method 3: Rescaling abundances to total MS intensity

The alternative: All normalized MS intensities added up together (mass-wise) should be proportional to the injected amount in ug (TPA approach):

`abundance = MS intensity * (injected amount )/(sum of all MS intensities*MW values)`

```{r rescaleData}
```

```{r}
ESdata    <- rescaleData(ESdata,'Intensity.L.T4h_','ES.',1.1e6) #1.1 ug = 1.1*10^6 pg
iBAQdata  <- rescaleData(iBAQdata,'Intensity.H.T4h_','IS.',6e6) #6 ug = 6*10^6 pg
```

We now use the absolute abundances from the IS (fmol/sample) to infer absolute abundances in each sample of the SILAC data (fmol/sample):

```{r}
SILACdata <- getSampleAbundance(SILACdata,iBAQdata,'Abundance.Rescaled')
```

## Method comparison

Let's take a look at the total detected protein amount in each of the 6 samples of IS, for all 3 methods:

```{r plotTotalProt}
```

```{r fig.height = 4, fig.width = 10, fig.align="center"}
par(mfcol = c(1,3), mar = c(2.5,2.5,1,1), cex = 1)
plotTotalProt(iBAQdata,'Abundance.MaxQuant.IS')
plotTotalProt(iBAQdata,'Abundance.Interp.IS')
plotTotalProt(iBAQdata,'Abundance.Rescaled.IS')
```

<center>**Figure 1: Total detected protein amounts in all 6 IS, according to MaxQuant (left), adjusted ES curve (middle) and rescaled (right).**</center>
<br>

Let's take a look at the total detected protein amount of each of the 18 samples, colored by the original ES curve used for the calibration (figure 1):

```{r fig.align="center"}
par(mfcol = c(1,3), mar = c(1,2.5,1,1), cex = 1)
plotTotalProt(SILACdata,'Abundance.MaxQuant.R..1_')
plotTotalProt(SILACdata,'Abundance.Interp.R..1_')
plotTotalProt(SILACdata,'Abundance.Rescaled.R..1_')
```

<center>**Figure 2: Total detected protein amounts in all 18 samples, according to MaxQuant (left), adjusted ES curve (middle) and rescaled (right).**</center>
<br>

The total detected protein seems to vary quite a bit among samples depending on the ES for any method with a ES curve.

Let's now take a look at the ES data + standard curves. For that we need:

* A function for plotting a linear fit (with a slope = 1):

```{r plotLM}
```

* A function for plotting the external standard:

```{r plotES}
```

* A function for plotting all 6 external standards (together or separate):

```{r plotAllES}
```

Now we can take a look at all 6 ES curves from method 2, and also for method 3, as we have essentially created an alternative linear model:

`abundance = m*MSintensity`, where `m = (6 ug)/(sum of all MSintensities*MWs)`

`log(abundance) = log(MSintensity) + log(m)` -> linear model with a = 1 and b = log(m)

```{r fig.align="center"}
iBAQpos <- grep('Intensity.H.T4h',names(iBAQdata))   #All 6 MS intensity values from the IS (H fraction)
Hdata   <- iBAQdata[,iBAQpos]*iBAQdata$Mol..weight..kDa.
scaling <- 6e6/colSums(Hdata, na.rm = TRUE)
plotAllES(ESdata,'Intensity.L.T4h_',scaling,FALSE)
```

<center>**Figure 3: ES curves (log10(abundance [pg/sample]) in y-axis Vs log10(MS intensity) in x-axis), original (red) Vs rescaled (green)**</center>
<br>

The red fits give us the transformation from light (L) MS intensity of the UPS2 proteins to abundance (fmol/sample) with the traditional method. But they don't look the best (consider they are in log), many other curves (could)as the green fits) can almost equally well fit that data. Let's see everything in the same plot:

```{r fig.align="center"}
plotAllES(ESdata,'Intensity.L.T4h_',scaling,TRUE)
```

<br>
<center>**Figure 4: ES curves (abundance Vs MS intensities of UPS2), original (red) Vs rescaled (green). Average coefficient of variation (CVm) within each protein in the log space is shown in the upper left corner.**</center>
<br>

Note that the MS precision is quite poor: the same protein detection can vary almost a full order of magnitude in some cases. This supports the idea that an alternative linear fit can replace the original ES curve, as both are an approximation anyway.
<br>

We now display the variability of the final abundance data between biological and technical replicates, and with Vs without rescaling. First we define a scatter plot helping function:

```{r plotScatter}
```

We now define a function that plots all possible combinations between replicates. For instance, for biological replicates, the text in the variable's label regarding biological replicate (`.R1.1`, `.R2.1` and `.R3.1`) will be first removed, and then 2 columns will be plotted against each other if the rest of the name matches (meaning it's the same technical replicate/MS method but 2 different biological replicates).

```{r plotVariability}
```

Finally, we define a PCA function to see how the samples cluster:

```{r plotPCA}
```

Let's now see the results of those plots:

```{r fig.align="center"}
par(mfrow = c(3,3), mar = c(0, 0, 1, 0) + 0.5, cex = 1)
# Top row: MaxQuant
abundance <- SILACdata[,grep('Abundance.MaxQuant.R',names(SILACdata))]
plotVariability(abundance,c('.R1.1','.R2.1','.R3.1'),'Biological Variability')
plotVariability(abundance,c('_Batch1','_Batch2','_Batch3'),'Technical Variability')
plotPCA(abundance,'PCA')
# Middle row: Interpolating with ES curve
abundance <- SILACdata[,grep('Abundance.Interp.R',names(SILACdata))]
plotVariability(abundance,c('.R1.1','.R2.1','.R3.1'),'Biological Variability')
plotVariability(abundance,c('_Batch1','_Batch2','_Batch3'),'Technical Variability')
plotPCA(abundance,'PCA')
# Bottom row: Rescaling
abundance <- SILACdata[,grep('Abundance.Rescaled.R',names(SILACdata))]
plotVariability(abundance,c('.R1.1','.R2.1','.R3.1'),'Biological Variability')
plotVariability(abundance,c('_Batch1','_Batch2','_Batch3'),'Technical Variability')
plotPCA(abundance,'PCA')
```

<center>**Figure 5: Comparison of data variability from MaxQuant (top row), using an ES curve (middle row) and rescaling (bottom row) In the variability plots (left and middle columns, log10(abundance [fmol/sample]) both in the x-axis and y-axis), 2 abundance values for a given protein are plotted if they belong to the same replicate (biological or technical), and green is a FC < 2, yellow between 2 and 10, and red > 10. In the PCA plots (right column), colors refer to technical replicates and shapes to biological replicates.**</center>
<br>

Even though the variability looks similar in all cases, we see a lower median fold change in the technical replicates + a better separation of the "technical clusters" in the PCA when we use the rescaling (PC1 represents less variability). This means that by using rescaled data we achieve lower variability between technical replicates.

Let's look further into the reduction of variability by plotting all possible FC (i.e. both between biological and technical replicates). For that we define the following function:

```{r getFCvsAbundance}
```

And the following plotting function that will plot each FC to the basal abundance, together with a "UPS2 window" that shows the abundance levels that are detected by the UPS2:

```{r plotFCvsAbundance}
```

We can now compare both methods:

```{r fig.height = 4, fig.width = 10, fig.align="center"}
par(mfrow = c(1,3), mar = c(4,4,1.5,0.5))
sample1 <- plotFCvsAbundance(SILACdata,ESdata,'Abundance.MaxQuant.R..1_',FALSE)
sample2 <- plotFCvsAbundance(SILACdata,ESdata,'Abundance.Interp.R..1_',FALSE)
sample3 <- plotFCvsAbundance(SILACdata,ESdata,'Abundance.Rescaled.R..1_',FALSE)
```

<center>**Figure 6: Fold change Vs abundances for all 3 methods. The detection window of UPS2 is highlighted in yellow.**</center>
<br>

We see that in all 3 cases more than 80% of the data falls within the detection range of UPS2, which is good. Also, all 3 datasets look similar in shape, so instead let's look at the trend of the data with the help of smooth splines:

```{r plotSplines}
```

Plotting now all data together with the smoothing splines for each method:

```{r fig.width = 4, fig.align="center"}
par(mfrow = c(1,1), mar = c(4,4,1.5,0.5))
plotSplines(SILACdata,ESdata)
```

<center>**Figure 7: Fold change Vs abundances for all 3 methods + smoothing splines (colors corresponding to the colors in figure 16). The detection window of UPS2 is highlighted in yellow.**</center>
<br>

We now see that our proposed method of rescaling by MS intensities has less overall variability than the other method, both for lowly and highly abundant proteins.

In conclusion, we can skip entirely the iBAQ data and just assume that the MS intensities should always adds up to a given protein amount, we can reproduce almost exactly the ES curves, and achieve more consistent results across samples. In this approach, the UPS2 data is only used to get an estimate of the detected total protein amount of the IS by the MS intensities.
<br>


## To-do's

* Include rescaled iBAQ values
* Plot comparing to real UPS2 values
* Is the order in ES data always the same?
* show only technical variability in abundance plots
* Validation to stoichiometry of ribosomal proteins
* ES curves relax slope = 1?

