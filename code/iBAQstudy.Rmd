---
title: "Supplementary Material"
author: "Benjamin J. Sanchez, Petri-Jaan Lahtvee, Kate Campbell, Sergo Kasvandik, Rosemary Yu, Ivan Domenzain, Aleksej Zelezniak and Jens Nielsen"
header-includes:
- \usepackage{float}
- \floatplacement{figure}{H}
output:
  pdf_document:
    toc: true
    toc_depth: 2
    number_sections: true
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dev = "png", dpi = 600)
```

# Summary

Here we will go through the typical way of deducing protein abundances [fmol/sample] from SILAC/iBAQ data, and compare it to rescaling values to a fix total protein abundance based on MS intensities, to asses the usefulness of the external standard curve and iBAQ data. The main observation that comes from this is that as MS measurements are so variable, it's impossible to find a unique ES curve, hence normalizing to a fix total protein abundance is as good as using the "optimal" fit from the ES curve. We can then use the MS intensity directly and skip both the ES curve and the iBAQ values.
<br>

# Loading and pre-processing data

## Loading packages

```{r warning = FALSE, message = FALSE, results = FALSE}
library(plyr)
library(knitr)
library(biomaRt)
```

```{r echo=FALSE}
read_chunk('loadData.R')
read_chunk('processData.R')
read_chunk('plotData.R')
read_chunk('mainFigures.R')
```

## Loading UPS2

The commercial kit brings 10.6 ug of protein, however only 1.1 ug are injected in the MS:

```{r loadUPS2}
```

## Loading iBAQ data

In the iBAQ data (IS+ES) there are 6 samples: 3 technical replicates (`batch1`, `batch2` & `batch3`) and each of them processed with 2 different MS methods `top5` & `top10`. We will have then 6 different ES curves:

* top5_batch1
* top5_batch2
* top5_batch3
* top10_batch1
* top10_batch2
* top10_batch3

```{r loadIBAQdata}
```

## Getting the ES data

In each sample of the iBAQ data there are:

* 6 ug of IS: yeast samples, all marked; i.e. will appear in the heavy fraction (H)
* 1.1 ug of ES: universal protein standard (UPS2) unmarked; i.e. will appear in the light fraction (L)

```{r splitIBAQdata}
```

## Loading SILAC data

There are 18 different samples:

* 3 biological replicates (`R1`, `R2` & `R3`)
* each with 3 technical replicates (`batch1`, `batch2` & `batch3`)
* each estimated with a different MS method (`top5` & `top10`)

Each injected sample consisted of:

* 6 ug of IS (detected in the H fraction)
* 6 ug of actual sample (detected in the L fraction)

```{r loadSILACdata}
```

## Loading ribosomal proteins

We use a list of ribosomal genes based on Jenner et al. (2012):  http://dx.doi.org/10.1016/j.sbi.2012.07.013

```{r loadRibProteins}
```

# Methods evaluated

## Method 1: iBAQ

Let's start by using the computed iBAQ abundances values by MaxQuant that come in the iBAQ data, which are infered using an ES curve of the UPS2 proteins (in the L fraction). As the data already comes in fmol/sample, the only thing missing is to use the values from the IS (H fraction) together with the normalized L/H ratios in the SILAC data for getting absolute abundances in each sample of the SILAC data (fmol/sample), by doing:

`abundance(sample) = (L/H)ratio * abundance(IS)`

```{r getSampleAbundance}
```

```{r}
SILACdata <- getSampleAbundance(SILACdata,ISdata,'iBAQ')
```

## Method 2: Rescaling iBAQ values

As iBAQ values don't add up always to the same totals (Figure \ref{fig:tot-es}), we should asses the benefits of rescaling all of these values to add up to the injected amounts:

`abundance = (iBAQ abundance)*(injected amount)/(sum of all iBAQ abundances*MW values)`

```{r rescaleData}
```

```{r}
ESdata    <- rescaleData(ESdata,'Abundance.iBAQ.ES.','iBAQrescaled.ES.',1.1e6) #1.1 ug
ISdata    <- rescaleData(ISdata,'Abundance.iBAQ.IS.','iBAQrescaled.IS.',6e6)   #6 ug
```

We now use the absolute abundances from the IS (fmol/sample) to infer absolute abundances in each sample of the SILAC data (fmol/sample):

```{r}
SILACdata <- getSampleAbundance(SILACdata,ISdata,'iBAQrescaled')
```

## Method 3: TPA

The alternative: To skip iBAQ values and ES curves entirely, and to assume all MS intensities added up together (mass-wise) should be proportional to the injected amount in ug (TPA approach):

`abundance = (MS intensity)*(injected amount)/(sum of all MS intensities*MW values)`

```{r}
ESdata    <- rescaleData(ESdata,'Intensity.L.T4h_','TPA.ES.',1.1e6) #1.1 ug
ISdata    <- rescaleData(ISdata,'Intensity.H.T4h_','TPA.IS.',6e6)   #6 ug
SILACdata <- getSampleAbundance(SILACdata,ISdata,'TPA')
```

## Method 4: Normalized TPA

We will also try out to first normalize all MS intensitiy values by the sequence length, as proxy for number of theoretical peptides:

```{r normalizeIntensities}
```

```{r}
ESdata <- normalizeIntensities(ESdata)
ISdata <- normalizeIntensities(ISdata)
```

Now we rescale the data as before:

```{r}
ESdata    <- rescaleData(ESdata,'Intensity.L.T4h_','TPAnorm.ES.',1.1e6) #1.1 ug
ISdata    <- rescaleData(ISdata,'Intensity.H.T4h_','TPAnorm.IS.',6e6)   #6 ug
SILACdata <- getSampleAbundance(SILACdata,ISdata,'TPAnorm')
```

Note that for methods 3 and 4 we have essentially created a linear model:

`abundance = m*MSintensity`, where `m = (6 ug)/(sum of all MSintensities*MWs)`

`log(abundance) = log(MSintensity) + log(m)` -> linear model with a = 1 and b = log(m) in the log space.

## Additional method: MS intensities using an ES curve

As we do not have the normalized intensities for the MaxQuant calculations of iBAQ abundances, we will use an additional method only for comparing the ES curves quality. Abundance of the IS here is computed by building a log-log standard curve for the ES and applying it to the normalized MS intensities from the IS (H fraction). Note that said ES curve MUST have slope = 1, as the underlying assumption is that MS intensities are linearly proportional to the mass of the corresponding proteins, therefore:

`moles = m*MSint`

`log10(moles) = log10(m*MSint)`

`log10(moles) = log10(MSint) + log10(m)`

So if the fit is done in the log space, we fix the ES curve to always have slope = 1, and find the corresponding fit for the intercept:

```{r interpolateAbundance}
```

```{r}
ISdata    <- interpolateAbundance(ISdata,'Intensity.H.T4h_','Interp.IS.')
ESdata    <- interpolateAbundance(ESdata,'Intensity.L.T4h_','Interp.ES.')
SILACdata <- getSampleAbundance(SILACdata,ISdata,'Interp')
```

# Method comparison

## Preliminar comparison

Let's plot the data between methods: For that we define a function that gives all possible combinations between replicates. For instance, for biological replicates, the text in the variable's label regarding biological replicate (`.R1.1`, `.R2.1` and `.R3.1`) will be first removed, and then 2 columns will be paired up if the rest of the name matches (meaning it's the same technical replicate/MS method but 2 different biological replicates). We can also use it to compare between methods by removing the method's name:

```{r getReplicateData}
```

We also need a couple of plotting functions:

```{r plotScatter}
```

```{r plotVariability}
```

```{r general-comp, fig.height = 6, fig.width = 10, fig.align = "center", fig.cap = "\\label{fig:general-comp}Comparison of predictions [fmol/sample] between all methods. Green is a FC < 2, yellow between 2 and 10, and red > 10."}
abundanceIBAQ <- SILACdata[,c(1,grep('Abundance.iBAQ.R',names(SILACdata)))]
abundanceIR   <- SILACdata[,c(1,grep('Abundance.iBAQrescaled.R',names(SILACdata)))]
abundanceTPA  <- SILACdata[,c(1,grep('Abundance.TPA.R',names(SILACdata)))]
abundanceTPAN <- SILACdata[,c(1,grep('Abundance.TPAnorm.R',names(SILACdata)))]
IRvsIBAQ   <- cbind(abundanceIBAQ[,-1],abundanceIR[,-1])
TPAvsIBAQ  <- cbind(abundanceIBAQ[,-1],abundanceTPA[,-1])
TPANvsIBAQ <- cbind(abundanceIBAQ[,-1],abundanceTPAN[,-1])
TPAvsIR    <- cbind(abundanceIR[,-1],abundanceTPA[,-1])
TPANvsIR   <- cbind(abundanceIR[,-1],abundanceTPAN[,-1])
TPANvsTPA  <- cbind(abundanceTPA[,-1],abundanceTPAN[,-1])
IBAQname   <- 'iBAQ [fmol/sample]'
IRname     <- 'iBAQ rescaled [fmol/sample]'
TPAname    <- 'TPA [fmol/sample]'
TPANname   <- 'TPA normalized [fmol/sample]'
par(mfrow = c(2,3), mar = c(4,4,2,1), cex = 1)
plotVariability(IRvsIBAQ, c('iBAQ.R','iBAQrescaled.R'), '', IBAQname, IRname, FALSE)
plotVariability(TPAvsIBAQ, c('iBAQ.R','TPA.R'), '', IBAQname, TPAname, FALSE)
plotVariability(TPANvsIBAQ, c('iBAQ.R','TPAnorm.R'), '', IBAQname, TPANname, FALSE)
plotVariability(TPAvsIR, c('iBAQrescaled.R','TPA.R'), '', IRname, TPAname, FALSE)
plotVariability(TPANvsIR, c('iBAQrescaled.R','TPAnorm.R'), '', IRname, TPANname, FALSE)
plotVariability(TPANvsTPA, c('TPA.R','TPAnorm.R'), '', TPAname, TPANname, FALSE)
```

Let's now see the predicted abundances of all samples compared to the sequence length:

```{r plotAbundancesVsLength}
```

```{r general-length, fig.height = 7, fig.width = 7, fig.align="center", fig.cap = "\\label{fig:general-length}Predicted abundances [fmol/sample] Vs protein length by all methods."}
par(mfrow = c(2,2), mar = c(4,4,2,1), cex = 1)
sampleNames <- c('Abundance.iBAQ.R','Abundance.iBAQrescaled.R',
                 'Abundance.TPA.R','Abundance.TPAnorm.R')
plotAbundancesVsLength(SILACdata,sampleNames)
```

We can see that methods 1,2 and 4 all have similar correlation values, while method 3 correlates less than the other 3 methods to protein length.
<br>

## Accuracy evaluation

Let's now compare accuracy. First, we compare the ES values predicted by each method to the actual UPS2 values:

```{r plotESdata}
```

```{r accuracy-ups2, fig.height = 7, fig.width = 7, fig.align="center", fig.cap = "\\label{fig:accuracy-ups2}Comparison of predicted Vs real abundance values [fmol/sample] from UPS2, according to all methods. Green is a FC < 2, yellow between 2 and 10, and red > 10."}
par(mfrow = c(2,2), mar = c(4,4,2,1), cex = 1)
FCups2IBAQ <- plotESdata(ESdata,'iBAQ')
FCups2IR   <- plotESdata(ESdata,'iBAQrescaled')
FCups2TPA  <- plotESdata(ESdata,'TPA')
FCups2TPAN <- plotESdata(ESdata,'TPAnorm')
```

We see that all predictions from methods 1, 2 and 4 are very similar; by using ES curves (methods 1-2) we don't gain much prediction power than if we just rescale the data (method 4). However, method 3 performs significantly worse.

Now, let's see how are the predictions of ribosomal subunits stoichiometry. For that first we create dataframes with only ribosomal proteins:

```{r getRPdata}
```

```{r}
rpIBAQ <- getRPdata(abundanceIBAQ,RP)
rpIR   <- getRPdata(abundanceIR,RP)
rpTPA  <- getRPdata(abundanceTPA,RP)
rpTPAN <- getRPdata(abundanceTPAN,RP)
```

Now we can plot for each method the corresponding data:

```{r plotRPdata}
```

```{r accuracy-ribosome, fig.height = 10, fig.width = 8, fig.align="center", fig.cap = "\\label{fig:accuracy-ribosome}Comparison of predicted ribosomal subunit abundances [fmol/sample], according to all methods. Colors correspond to different technical replicates. The median value is displayed with a segmented line, and the median fold change to that line for all data is displayed."}
par(mfrow = c(4,1), mar = c(4,4,2,1), cex = 1)
FCrpIBAQ <- plotRPdata(rpIBAQ,'iBAQ')
FCrpIR   <- plotRPdata(rpIR,'iBAQrescaled')
FCrpTPA  <- plotRPdata(rpTPA,'TPA')
FCrpTPAN <- plotRPdata(rpTPAN,'TPAnorm')
```

These distributions are not very different between them (with exception of method 3), as we can see in the cumulative distributions:

```{r plotCumulativeDistrib}
```

```{r accuracy-cdf, warning = FALSE, fig.height = 5, fig.width = 8, fig.align = "center", fig.cap = "\\label{fig:accuracy-cdf}Cumulative distributions of absolute fold changes for both accuracy evaluation metrics: differences of predicted Vs experimental values of UPS2 (left) and differences to median value in ribosomal measurements (right). A fold change of 2 is indicated with a vertical segmented line. Colors represent the methods: iBAQ (red), iBAQ rescaled (green), TPA (blue) and TPA normalized (cyan)."}
ups2FC <- data.frame(FCups2IBAQ,FCups2IR,FCups2TPA,FCups2TPAN)
rpFC   <- data.frame(FCrpIBAQ,FCrpIR,FCrpTPA,FCrpTPAN)
par(mfrow = c(1,2), mar = c(4,4,2,1), cex = 1)
plotCumulativeDistrib(ups2FC,'UPS2 abundance error')
plotCumulativeDistrib(rpFC,'Ribosomal stoichiometry variability')
```

## Protein totals

Let's now take a look at the total detected protein amount in each of the 6 samples of IS, for all methods:

```{r plotTotalProt}
```

```{r tot-es, fig.height = 3, fig.width = 10, fig.align = "center", fig.cap = "\\label{fig:tot-es}Total detected protein amounts in all 6 IS, according to all methods."}
par(mfcol = c(1,4), mar = c(1,2.5,2,1), cex = 1)
ISnames <- c('Abundance.iBAQ.IS','Abundance.iBAQrescaled.IS',
             'Abundance.TPA.IS','Abundance.TPAnorm.IS')
for(name in ISnames) {
  plotTotalProt(ISdata,name)
}
```

Let's also take a look at the total detected protein amount of each of the 18 samples, colored by the original ES curve used for the calibration (Figure \ref{fig:tot-es}):

```{r tot-samples, fig.height = 3, fig.width = 10, fig.align = "center", fig.cap = "\\label{fig:tot-samples}Total detected protein amounts in all 18 samples, according to all methods."}
par(mfcol = c(1,4), mar = c(1,2.5,2,1), cex = 1)
sampleNames <- c('Abundance.iBAQ.R..1_','Abundance.iBAQrescaled.R..1_',
                 'Abundance.TPA.R..1_','Abundance.TPAnorm.R..1_')
for(name in sampleNames) {
  plotTotalProt(SILACdata,name)
}
```

The total detected protein seems to vary quite a bit among samples calculated with iBAQ, and as expected this reduces if we rescale the IS abundances.

## ES curves

Let's now take a look at the ES data + standard curves from method 4, compared to the alternative method (using an ES curve on the normalized MS intensities). For that we need:

* A function for plotting a linear fit (with a slope = 1):

```{r plotLM}
```

* A function for plotting the external standard:

```{r plotES}
```

* A function for plotting all 6 external standards (together or separate):

```{r plotAllES}
```

Note that we cannot look at the ES curves of methods 1 and 2 as we do not have the values for the normalized MS intensities by MaxQuant (the software does not provide them).

```{r es-separate, fig.align = "center", fig.cap = "\\label{fig:es-separate}ES curves (log10(abundance [fmol/sample]) in y-axis Vs log10(normalized MS intensity) in x-axis), with (green) and without (red) rescaling. Within each of the 4 orders of magnitude, each symbol corresponds to a different protein."}
#All 6 MS intensity values from the IS (H fraction):
ISpos <- grep('Intensity.H.T4h',names(ISdata))
Hdata   <- ISdata[,ISpos]*ISdata$Mol..weight..kDa.
scaling <- 6e6/colSums(Hdata, na.rm = TRUE)
plotAllES(ESdata,'Intensity.L.T4h_',scaling,FALSE)
```

The red fits give us the transformation from light (L) MS intensity of the UPS2 proteins to abundance (fmol/sample) with the traditional approach. But they don't look the best (consider they are in log), many other curves (as the green fits) can almost equally well fit that data. Let's see everything in the same plot:

```{r es-together, fig.align = "center", fig.cap = "\\label{fig:es-together}ES curves (log10(abundance [fmol/sample]) in y-axis Vs log10(MS intensity) in x-axis), with (green) and without (red) rescaling. Average coefficient of variation (CVm) within each protein is shown in the upper left corner."}
plotAllES(ESdata,'Intensity.L.T4h_',scaling,TRUE)
```

Note that the MS precision is quite poor: the same protein detection can vary almost a full order of magnitude in some cases. This supports the idea that an alternative linear fit can replace the original ES curve, as both are an approximation anyway.

## Evaluating precision

We now display the variability of the final abundance data between biological and technical replicates, for all methods, using variability plots and a PCA:

```{r plotPCA}
```

```{r plotAllVariability}
```

```{r precision-all, fig.height = 12, fig.width = 10, fig.align = "center", fig.cap = "\\label{fig:precision-all}Comparison of data variability from iBAQ (1st row), rescaling iBAQ (2nd row), TPA (3rd row) and normalized TPA (4th row). In the variability plots (left and middle columns, log10(abundance [fmol/sample]) both in the x-axis and y-axis), 2 abundance values for a given protein are plotted if they belong to the same replicate (biological or technical, respectively), and green is a FC < 2, yellow between 2 and 10, and red > 10. In the PCA plots (right column), colors refer to technical replicates and shapes to biological replicates."}
par(mfrow = c(4,3), mar = c(0, 0, 1, 0) + 0.5, cex = 1)
plotAllVariability(abundanceIBAQ)
plotAllVariability(abundanceIR)
plotAllVariability(abundanceTPA)
plotAllVariability(abundanceTPAN)
```

We see a lower median fold change in the technical replicates + a better separation of the "technical clusters" in the PCA when we rescale the normalized MS abundancies (PC1 represents less variability). This means that by using rescaled normalized MS data we achieve lower variability between technical replicates than the other 2 methods.

## Evaluating technical precision

Let's look further into the reduction of technical variability:

```{r precision-tech, fig.width = 4, fig.align = "center", fig.cap = "\\label{fig:precision-tech}Fold change cumulative distributions for all methods. A fold change of 2 is indicated with a vertical segmented line. Colors represent the methods: iBAQ (red), iBAQ rescaled (green), TPA (blue) and TPA normalized (cyan)."}
par(mfrow = c(1,1), mar = c(4,4,1.5,0.5))
names      <- c('_batch1','_batch2','_batch3')
FCtechIBAQ <- getReplicateData(abundanceIBAQ[,-1],names,2,FALSE)
FCtechIR   <- getReplicateData(abundanceIR[,-1],names,2,FALSE)
FCtechTPA  <- getReplicateData(abundanceTPA[,-1],names,2,FALSE)
FCtechTPAN <- getReplicateData(abundanceTPAN[,-1],names,2,FALSE)
techFC     <- data.frame(FCtechIBAQ[,2],FCtechIR[,2],FCtechTPA[,2],FCtechTPAN[,2])
plotCumulativeDistrib(techFC,'Technical variability')
```

We can also look at technical variability by plotting each FC to the basal abundance, together with a "UPS2 window" that shows the abundance levels that are detected by the UPS2:

```{r plotFCvsAbundance}
```

We can now compare again the methods:

```{r precision-abundance, fig.height = 3, fig.width = 10, fig.align = "center", fig.cap = "\\label{fig:precision-abundance}Fold change Vs abundances for all methods. The detection window of UPS2 and the UPS2 datapoints are highlighted in yellow."}
par(mfrow = c(1,4), mar = c(4,4,1.5,0.5))
for(name in sampleNames) {
  tmp <- plotFCvsAbundance(SILACdata,ESdata,name,FALSE)
}
```

We see that in all cases more than 80% of the data falls within the detection range of UPS2, which is good. However, all datasets look similar in shape, so instead let's look at the trend of the data with the help of smooth splines:

```{r plotSplines}
```

Plotting now all data together with the smoothing splines for each method:

```{r precision-splines, fig.width = 4, fig.align = "center", fig.cap = "\\label{fig:precision-splines}Fold change Vs abundances for all methods + smoothing splines. Colors represent the methods: iBAQ (red), iBAQ rescaled (green), TPA (blue) and TPA normalized (cyan). The detection window of UPS2 is highlighted in yellow."}
par(mfrow = c(1,1), mar = c(4,4,1.5,0.5))
plotSplines(SILACdata,ESdata)
```

We now see that our proposed method of rescaling by normalized MS intensities has less overall variability than the both iBAQ and rescaled iBAQ, both for lowly and highly abundant proteins.

In conclusion, we can skip entirely the UPS2 data and just assume that the normalized MS intensities should always adds up to a given protein amount. With this, we can reproduce very closely the ES curves, and achieve more consistent results across samples. In this approach, the iBAQ run is only used to do the rescaling, but this could be equally performed with any SILAC run.

# Main figures of manuscript

Figure 1:

```{r figure1, results="hide", warning = FALSE}
```

Figure 2:

```{r figure2, results="hide", warning = FALSE}
```

